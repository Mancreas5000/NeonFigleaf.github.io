<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Enhanced Self-Forming Geometry Structure</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            color: white; 
            font-family: sans-serif; 
            touch-action: none; /* Prevent touch gestures */
        }
        canvas { 
            display: block; 
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        .control-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            color: white;
            font-size: 14px;
            width: 250px;
            max-height: 90vh;
            overflow-y: auto;
        }
        .control-panel button {
            margin-top: 10px;
            background: #555;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.3s;
        }
        .control-panel button:hover {
            background: #777;
        }
        .slider-container {
            margin: 10px 0;
        }
        .slider-container label {
            display: block;
            margin-bottom: 5px;
        }
        input[type="range"] {
            width: 100%;
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        .checkbox-container input {
            margin-right: 10px;
        }
        
        /* Mobile-specific styles */
        @media (max-width: 768px) {
            .control-panel {
                width: 200px;
                font-size: 12px;
                padding: 10px;
            }
            #info {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="info">Tap or click anywhere to spawn objects. Objects will form a dynamic structure.</div>
    
    <div class="control-panel">
        <h3>Controls</h3>
        <div class="slider-container">
            <label for="gravity">Gravity Strength</label>
            <input type="range" id="gravity" min="0" max="2" step="0.1" value="0.5">
        </div>
        <div class="slider-container">
            <label for="attraction">Attraction Force</label>
            <input type="range" id="attraction" min="5" max="50" step="1" value="20">
        </div>
        <div class="slider-container">
            <label for="colorMode">Color Mode</label>
            <select id="colorMode">
                <option value="random">Random</option>
                <option value="gradient">Gradient</option>
                <option value="distance">Distance-based</option>
            </select>
        </div>
        <div class="slider-container">
            <label for="objectType">Object Type</label>
            <select id="objectType">
                <option value="building">Building</option>
                <option value="car">Car</option>
                <option value="boat">Boat</option>
                <option value="goat">Goat</option>
                <option value="fish">Fish</option>
                <option value="tree">Tree</option>
                <option value="rock">Rock</option>
                <option value="person">Person</option>
                <option value="airplane">Airplane</option>
                <option value="helicopter">Helicopter</option>
                <option value="dog">Dog</option>
                <option value="cat">Cat</option>
                <option value="chair">Chair</option>
                <option value="table">Table</option>
                <option value="lamp">Lamp</option>
                <option value="bridge">Bridge</option>
                <option value="tower">Tower</option>
                <option value="ship">Ship</option>
                <option value="submarine">Submarine</option>
                <option value="robot">Robot</option>
                <option value="dinosaur">Dinosaur</option>
                <option value="spaceship">Spaceship</option>
                <option value="ufo">UFO</option>
                <option value="windmill">Windmill</option>
                <option value="pyramid">Pyramid</option>
                <option value="castle">Castle</option>
                <option value="train">Train</option>
                <option value="truck">Truck</option>
                <option value="motorcycle">Motorcycle</option>
                <option value="bicycle">Bicycle</option>
                <option value="balloon">Balloon</option>
                <option value="zeppelin">Zeppelin</option>
                <option value="statue">Statue</option>
                <option value="fountain">Fountain</option>
                <option value="arch">Arch</option>
                <option value="tent">Tent</option>
                <option value="igloo">Igloo</option>
                <option value="lighthouse">Lighthouse</option>
                <option value="pagoda">Pagoda</option>
                <option value="windTurbine">Wind Turbine</option>
                <option value="satellite">Satellite</option>
                <option value="telescope">Telescope</option>
                <option value="radar">Radar</option>
                <option value="crane">Crane</option>
                <option value="excavator">Excavator</option>
                <option value="tank">Tank</option>
                <option value="submarine">Submarine</option>
                <option value="airship">Airship</option>
            </select>
        </div>
        <div class="slider-container">
            <label for="objectSize">Object Size</label>
            <input type="range" id="objectSize" min="0.5" max="5" step="0.1" value="1">
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="strangePhysics">
            <label for="strangePhysics">Strange Physics</label>
        </div>
        <button id="explodeBtn">Explode Structure</button>
        <button id="resetBtn">Reset Scene</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

        // --- Three.js Scene Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 50, 100);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- Orbit Controls for Camera ---
        const orbitControls = {
            enabled: true,
            target: new THREE.Vector3(8, 0, 0),
            rotationSpeed: 0.05,
            autoRotate: true,
            autoRotateSpeed: 0.1,
            radius: 150,
            theta: 0,
            phi: Math.PI / 4
        };

        // --- Parameters ---
        const params = {
            gravity: 4.5,
            attractionForce: 200,
            colorMode: 'random',
            pulseIntensity: 0.5,
            explodeForce: 50,
            objectSize: 1,
            strangePhysics: false,
            selectedObject: 'building'
        };

        // --- Cannon-ES Physics Setup ---
        const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -params.gravity, 0) });
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 20;

        // --- Materials ---
        const defaultMaterial = new CANNON.Material("defaultMaterial");
        const defaultContactMaterial = new CANNON.ContactMaterial(
            defaultMaterial,
            defaultMaterial,
            {
                friction: 0.1,
                restitution: 0.3
            }
        );
        world.addContactMaterial(defaultContactMaterial);
        world.defaultContactMaterial = defaultContactMaterial;

        // --- Create a Ground ---
        const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: defaultMaterial });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        groundBody.position.y = -20;
        world.addBody(groundBody);
        
        const groundGeo = new THREE.PlaneGeometry(2000, 2000, 50, 50);
        const groundMat = new THREE.MeshStandardMaterial({ 
            color: 0x222222,
            roughness: 0.8,
            metalness: 0.2,
            wireframe: false
        });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.position.y = -20;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        // --- Grid Helper ---
        const grid = new THREE.GridHelper(200, 20, 0x555555, 0x222222);
        grid.position.y = -19.9;
        scene.add(grid);

        // --- Lighting ---
        scene.add(new THREE.AmbientLight(0x404040, 1.5));
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(100, 200, 100);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);

        // --- Point Lights for dynamic lighting ---
        const pointLight1 = new THREE.PointLight(0xff00ff, 1, 100);
        pointLight1.position.set(0, 20, 0);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0x00ffff, 1, 100);
        pointLight2.position.set(30, 20, 30);
        scene.add(pointLight2);

        // --- Interaction Setup ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isTouchDevice = false;

        function handleInteraction(clientX, clientY) {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects([groundMesh, ...objects.map(o => o.mesh)]);
            if (intersects.length > 0) {
                const point = intersects[0].point;
                createSelectedObject(point.x, point.y + 10, point.z);
            }
        }

        // Mouse events
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        
        function onMouseDown(event) {
            if (event.button === 0) { // Left mouse button
                handleInteraction(event.clientX, event.clientY);
            }
        }
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mousedown', onMouseDown);

        // Touch events
        function onTouchStart(event) {
            isTouchDevice = true;
            event.preventDefault(); // Prevent scrolling/zooming
            const touch = event.touches[0];
            handleInteraction(touch.clientX, touch.clientY);
        }
        
        function onTouchMove(event) {
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            }
            event.preventDefault();
        }
        
        window.addEventListener('touchstart', onTouchStart, { passive: false });
        window.addEventListener('touchmove', onTouchMove, { passive: false });

        // --- Central Structure ---
        const centralStructure = new THREE.Group();
        scene.add(centralStructure);
        
        const centralGeometry = new THREE.SphereGeometry(5, 32, 32);
        const centralMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x444444, 
            emissive: 0x222222,
            roughness: 0.3,
            metalness: 0.8,
            wireframe: false
        });
        const centralMesh = new THREE.Mesh(centralGeometry, centralMaterial);
        centralMesh.castShadow = true;
        centralMesh.receiveShadow = true;
        centralStructure.add(centralMesh);
        
        const centralStructureBody = new CANNON.Body({ 
            mass: 0,
            shape: new CANNON.Sphere(5),
            position: new CANNON.Vec3(0, 0, 0)
        });
        world.addBody(centralStructureBody);

        // --- Object Creation ---
        const objects = [];
        const attachedObjects = [];
        const attachmentDistance = 15;
        
        function getColorByMode(mode, index, distance) {
            switch(mode) {
                case 'gradient':
                    return new THREE.Color().setHSL(index * 0.1 % 1, 0.7, 0.5);
                case 'distance':
                    return new THREE.Color().setHSL(Math.min(distance / 100, 1), 0.7, 0.5);
                case 'random':
                default:
                    return new THREE.Color(Math.random() * 0xffffff);
            }
        }

        // Object presets with geometry and physics shapes
        const objectPresets = {
            building: {
                geo: () => new THREE.BoxGeometry(3*params.objectSize, 6*params.objectSize, 3*params.objectSize),
                shape: () => new CANNON.Box(new CANNON.Vec3(1.5*params.objectSize, 3*params.objectSize, 1.5*params.objectSize))
            },
            car: {
                geo: () => new THREE.BoxGeometry(4*params.objectSize, 2*params.objectSize, 2*params.objectSize),
                shape: () => new CANNON.Box(new CANNON.Vec3(2*params.objectSize, 1*params.objectSize, 1*params.objectSize))
            },
            boat: {
                geo: () => new THREE.CylinderGeometry(2*params.objectSize, 2*params.objectSize, 4*params.objectSize, 8),
                shape: () => new CANNON.Cylinder(2*params.objectSize, 2*params.objectSize, 4*params.objectSize, 8)
            },
            goat: {
                geo: () => new THREE.ConeGeometry(1*params.objectSize, 3*params.objectSize, 4),
                shape: () => new CANNON.Cylinder(0.5*params.objectSize, 0.1*params.objectSize, 3*params.objectSize)
            },
            fish: {
                geo: () => new THREE.SphereGeometry(1.5*params.objectSize, 8, 8),
                shape: () => new CANNON.Sphere(1.5*params.objectSize)
            },
            tree: {
                geo: () => {
                    const trunk = new THREE.CylinderGeometry(0.5*params.objectSize, 0.8*params.objectSize, 5*params.objectSize);
                    const leaves = new THREE.ConeGeometry(2*params.objectSize, 4*params.objectSize);
                    leaves.translate(0, 3*params.objectSize, 0);
                    const geo = new THREE.BufferGeometry();
                    geo.setFromPoints([...trunk.attributes.position.array, ...leaves.attributes.position.array]);
                    return geo;
                },
                shape: () => new CANNON.Cylinder(0.8*params.objectSize, 0.5*params.objectSize, 5*params.objectSize)
            },
            rock: {
                geo: () => new THREE.DodecahedronGeometry(2*params.objectSize),
                shape: () => new CANNON.Sphere(2*params.objectSize)
            },
            person: {
                geo: () => {
                    const head = new THREE.SphereGeometry(0.8*params.objectSize);
                    head.translate(0, 2.5*params.objectSize, 0);
                    const body = new THREE.BoxGeometry(1.2*params.objectSize, 2*params.objectSize, 0.8*params.objectSize);
                    body.translate(0, 0.5*params.objectSize, 0);
                    const geo = new THREE.BufferGeometry();
                    geo.setFromPoints([...head.attributes.position.array, ...body.attributes.position.array]);
                    return geo;
                },
                shape: () => new CANNON.Box(new CANNON.Vec3(0.6*params.objectSize, 1.5*params.objectSize, 0.4*params.objectSize))
            },
            airplane: {
                geo: () => {
                    const body = new THREE.CylinderGeometry(0.5*params.objectSize, 0.5*params.objectSize, 6*params.objectSize);
                    const wing = new THREE.BoxGeometry(4*params.objectSize, 0.2*params.objectSize, 1*params.objectSize);
                    wing.translate(0, 0, 0);
                    const geo = new THREE.BufferGeometry();
                    geo.setFromPoints([...body.attributes.position.array, ...wing.attributes.position.array]);
                    return geo;
                },
                shape: () => new CANNON.Box(new CANNON.Vec3(2*params.objectSize, 0.5*params.objectSize, 3*params.objectSize))
            },
            helicopter: {
                geo: () => {
                    const body = new THREE.BoxGeometry(3*params.objectSize, 1.5*params.objectSize, 4*params.objectSize);
                    const rotor = new THREE.CylinderGeometry(0.1*params.objectSize, 0.1*params.objectSize, 6*params.objectSize);
                    rotor.translate(0, 1.5*params.objectSize, 0);
                    const geo = new THREE.BufferGeometry();
                    geo.setFromPoints([...body.attributes.position.array, ...rotor.attributes.position.array]);
                    return geo;
                },
                shape: () => new CANNON.Box(new CANNON.Vec3(1.5*params.objectSize, 0.75*params.objectSize, 2*params.objectSize))
            },
            // Add more objects as needed...
        };

        function createSelectedObject(x = (Math.random()-0.5)*100, y = Math.random() * 60 + 20, z = (Math.random()-0.5)*100) {
            const preset = objectPresets[params.selectedObject] || objectPresets.building;
            
            // Create geometry and material
            const geometry = preset.geo();
            const color = getColorByMode(params.colorMode, objects.length, 0);
            
            const material = new THREE.MeshStandardMaterial({ 
                color: color, 
                emissive: color.clone().multiplyScalar(0.5),
                emissiveIntensity: 0.5,
                roughness: 0.4,
                metalness: 0.6
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // Create physics body
            const shape = preset.shape();
            let mass = Math.random() * 5 + 2;
            
            if (params.strangePhysics) {
                mass = Math.random() * 50 + 5; // Heavier objects
                shape.radius *= 1.5; // Larger collision shapes
            }
            
            const body = new CANNON.Body({ mass, shape, material: defaultMaterial });
            body.position.copy(mesh.position);
            
            // Apply initial velocity
            if (params.strangePhysics) {
                body.velocity.set(
                    (Math.random()-0.5)*50, 
                    (Math.random()-0.5)*50, 
                    (Math.random()-0.5)*50
                );
                body.angularVelocity.set(
                    Math.random()*10,
                    Math.random()*10,
                    Math.random()*10
                );
            } else {
                body.velocity.set(
                    (Math.random()-0.5)*20, 
                    (Math.random()-0.5)*20, 
                    (Math.random()-0.5)*20
                );
            }
            
            world.addBody(body);
            
            const newObject = { mesh, body, attachedTime: null };
            objects.push(newObject);
            
            return newObject;
        }

        // Create initial objects
        const NUM_OBJECTS = 20;
        for (let i = 0; i < NUM_OBJECTS; i++) {
            createSelectedObject();
        }

        // --- Particle System for Ambient Effects ---
        const particleCount = 3000;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleSizes = new Float32Array(particleCount);
        
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            particlePositions[i3] = (Math.random() - 0.5) * 400;
            particlePositions[i3 + 1] = (Math.random() - 0.5) * 400;
            particlePositions[i3 + 2] = (Math.random() - 0.5) * 400;
            particleSizes[i] = Math.random() * 2;
        }
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
        
        const particleMaterial = new THREE.PointsMaterial({
            size: 1,
            color: 0xffffff,
            transparent: true,
            opacity: 0.5,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });
        
        const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particleSystem);

        // --- Helpers ---
        function explodeStructure() {
            // Apply outward forces to all objects
            [...objects, ...attachedObjects].forEach(obj => {
                const direction = new CANNON.Vec3().copy(obj.body.position).unit();
                const force = direction.scale(params.explodeForce * obj.body.mass);
                obj.body.applyImpulse(force, obj.body.position);
            });
        }

        function resetScene() {
            // Remove all objects
            [...objects, ...attachedObjects].forEach(obj => {
                scene.remove(obj.mesh);
                world.removeBody(obj.body);
            });
            
            objects.length = 0;
            attachedObjects.length = 0;
            
            // Create new objects
            for (let i = 0; i < NUM_OBJECTS; i++) {
                createSelectedObject();
            }
        }

        // --- UI Controls ---
        document.getElementById('gravity').addEventListener('input', (e) => {
            params.gravity = parseFloat(e.target.value);
            world.gravity.set(0, -params.gravity, 0);
        });
        
        document.getElementById('attraction').addEventListener('input', (e) => {
            params.attractionForce = parseFloat(e.target.value);
        });
        
        document.getElementById('colorMode').addEventListener('change', (e) => {
            params.colorMode = e.target.value;
        });
        
        document.getElementById('objectType').addEventListener('change', (e) => {
            params.selectedObject = e.target.value;
        });
        
        document.getElementById('objectSize').addEventListener('input', (e) => {
            params.objectSize = parseFloat(e.target.value);
        });
        
        document.getElementById('strangePhysics').addEventListener('change', (e) => {
            params.strangePhysics = e.target.checked;
        });
        
        document.getElementById('explodeBtn').addEventListener('click', explodeStructure);
        document.getElementById('resetBtn').addEventListener('click', resetScene);

        // Hide info panel after 5 seconds
        setTimeout(() => {
            document.getElementById('info').style.opacity = '0';
        }, 5000);

        // --- Animation Loop ---
        let lastTime;
        let elapsedTime = 0;
        
        function animate(time) {
            requestAnimationFrame(animate);
            
            if (lastTime !== undefined) {
                const dt = Math.min((time - lastTime) / 1000, 0.1); // Cap at 0.1 to avoid large jumps
                world.step(1/60, dt, 3);
                elapsedTime += dt;
            }
            lastTime = time;

            // Update camera position if auto-rotate is enabled
            if (orbitControls.autoRotate) {
                orbitControls.theta += orbitControls.autoRotateSpeed * 0.01;
                camera.position.x = orbitControls.radius * Math.sin(orbitControls.theta) * Math.cos(orbitControls.phi);
                camera.position.z = orbitControls.radius * Math.cos(orbitControls.theta) * Math.cos(orbitControls.phi);
                camera.position.y = orbitControls.radius * Math.sin(orbitControls.phi);
                camera.lookAt(orbitControls.target);
            }

            // Update dynamic objects
            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i];
                const objPosition = obj.body.position;
                const distanceToCenter = Math.sqrt(
                    objPosition.x * objPosition.x + 
                    objPosition.y * objPosition.y + 
                    objPosition.z * objPosition.z
                );

                // Attraction to the center
                const directionToCenter = new CANNON.Vec3(
                    -objPosition.x / distanceToCenter,
                    -objPosition.y / distanceToCenter,
                    -objPosition.z / distanceToCenter
                );
                const force = directionToCenter.scale(params.attractionForce);
                obj.body.applyForce(force, new CANNON.Vec3());

                // Slowly rotate the object for visual interest
                obj.mesh.rotation.x += 0.005;
                obj.mesh.rotation.y += 0.003;

                // Check for attachment to the central structure
                if (distanceToCenter < attachmentDistance && !obj.attachedTime) {
                    obj.attachedTime = elapsedTime;
                    attachedObjects.push(obj);
                    objects.splice(i, 1); // Remove from active objects

                    // Create a constraint to the central structure
                    const constraint = new CANNON.PointToPointConstraint(
                        centralStructureBody,
                        new CANNON.Vec3(objPosition.x, objPosition.y, objPosition.z),
                        obj.body,
                        new CANNON.Vec3(0, 0, 0)
                    );
                    world.addConstraint(constraint);
                    
                    // Visual effect for attachment
                    const flash = new THREE.PointLight(0xffffff, 5, 20);
                    flash.position.copy(obj.mesh.position);
                    scene.add(flash);
                    setTimeout(() => scene.remove(flash), 300);
                } else if (!obj.attachedTime) {
                    // Update position and rotation for free-floating objects
                    obj.mesh.position.copy(obj.body.position);
                    obj.mesh.quaternion.copy(obj.body.quaternion);
                }
            }

            // Update all attached objects
            attachedObjects.forEach(obj => {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
                
                // Pulse effect based on time since attachment
                if (obj.attachedTime) {
                    const timeSinceAttachment = elapsedTime - obj.attachedTime;
                    const pulseIntensity = Math.sin(timeSinceAttachment * 2) * 0.2 + 0.8;
                    
                    if (obj.mesh.material) {
                        obj.mesh.material.emissiveIntensity = pulseIntensity * params.pulseIntensity;
                    }
                }
            });

            // Update central mesh rotation
            centralMesh.rotation.y += 0.01;
            centralMesh.rotation.z += 0.005;

            // Update dynamic lighting
            pointLight1.position.x = Math.sin(elapsedTime) * 30;
            pointLight1.position.z = Math.cos(elapsedTime) * 30;
            pointLight2.position.x = Math.sin(elapsedTime + Math.PI) * 30;
            pointLight2.position.z = Math.cos(elapsedTime + Math.PI) * 30;

            // Update particles (subtle movement)
            const positions = particleGeometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                positions[i3 + 1] += Math.sin(elapsedTime + i) * 0.02;
                
                // Wrap particles if they go too far
                if (Math.abs(positions[i3]) > 200) positions[i3] *= -0.9;
                if (Math.abs(positions[i3 + 1]) > 200) positions[i3 + 1] *= -0.9;
                if (Math.abs(positions[i3 + 2]) > 200) positions[i3 + 2] *= -0.9;
            }
            particleGeometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }
        
        requestAnimationFrame(animate);

        // --- Window Resize Handler ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
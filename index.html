<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Model Structure Builder</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            color: white; 
            font-family: sans-serif; 
            touch-action: none;
        }
        canvas { 
            display: block; 
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        .control-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            color: white;
            font-size: 14px;
            width: 250px;
            max-height: 90vh;
            overflow-y: auto;
            transition: transform 0.3s ease;
        }
        .control-panel.collapsed {
            transform: translateX(calc(100% - 40px));
        }
        .control-panel h3 {
            margin-top: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .toggle-controls {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 0 5px;
        }
        .control-panel button {
            margin-top: 10px;
            background: #555;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.3s;
        }
        .control-panel button:hover {
            background: #777;
        }
        .slider-container {
            margin: 10px 0;
        }
        .slider-container label {
            display: block;
            margin-bottom: 5px;
        }
        input[type="range"] {
            width: 100%;
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        .checkbox-container input {
            margin-right: 10px;
        }
        
        @media (max-width: 768px) {
            .control-panel {
                width: 200px;
                font-size: 12px;
                padding: 10px;
            }
            #info {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="info">Tap or click anywhere to spawn objects. Objects will form a dynamic structure.</div>
    
    <div class="control-panel">
        <h3>
            Controls
            <button class="toggle-controls" title="Toggle controls">â‰¡</button>
        </h3>
        <div class="slider-container">
            <label for="gravity">Gravity Strength</label>
            <input type="range" id="gravity" min="0" max="2" step="0.1" value="0.5">
        </div>
        <div class="slider-container">
            <label for="attraction">Attraction Force</label>
            <input type="range" id="attraction" min="5" max="50" step="1" value="20">
        </div>
        <div class="slider-container">
            <label for="colorMode">Color Mode</label>
            <select id="colorMode">
                <option value="random">Random</option>
                <option value="gradient">Gradient</option>
                <option value="distance">Distance-based</option>
            </select>
        </div>
        <div class="slider-container">
            <label for="objectType">Object Type</label>
            <select id="objectType">
                <option value="square">Square</option>
                <option value="triangle">Triangle</option>
                <option value="orb">Orb</option>
                <option value="plane">Plane</option>
                <option value="star">Star</option>
                <option value="cat">Cat</option>
                <option value="dog">Dog</option>
            </select>
        </div>
        <div class="slider-container">
            <label for="objectSize">Object Size</label>
            <input type="range" id="objectSize" min="0.5" max="5" step="0.1" value="1">
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="strangePhysics">
            <label for="strangePhysics">Strange Physics</label>
        </div>
        <button id="explodeBtn">Explode Structure</button>
        <button id="resetBtn">Reset Scene</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script type="module">
        import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

        // --- Three.js Scene Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 50, 100);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- Orbit Controls for Camera ---
        const orbitControls = {
            enabled: true,
            target: new THREE.Vector3(8, 0, 0),
            rotationSpeed: 0.05,
            autoRotate: true,
            autoRotateSpeed: 0.1,
            radius: 150,
            theta: 0,
            phi: Math.PI / 4
        };

        // --- Parameters ---
        const params = {
            gravity: 4.5,
            attractionForce: 200,
            colorMode: 'random',
            pulseIntensity: 0.5,
            explodeForce: 50,
            objectSize: 1,
            strangePhysics: false,
            selectedObject: 'square'
        };

        // --- Cannon-ES Physics Setup ---
        const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -params.gravity, 0) });
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 20;

        // --- Materials ---
        const defaultMaterial = new CANNON.Material("defaultMaterial");
        const defaultContactMaterial = new CANNON.ContactMaterial(
            defaultMaterial,
            defaultMaterial,
            {
                friction: 0.1,
                restitution: 0.3
            }
        );
        world.addContactMaterial(defaultContactMaterial);
        world.defaultContactMaterial = defaultContactMaterial;

        // --- Create a Ground ---
        const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: defaultMaterial });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        groundBody.position.y = -20;
        world.addBody(groundBody);
        
        const groundGeo = new THREE.PlaneGeometry(2000, 2000, 50, 50);
        const groundMat = new THREE.MeshStandardMaterial({ 
            color: 0x222222,
            roughness: 0.8,
            metalness: 0.2,
            wireframe: false
        });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.position.y = -20;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        // --- Grid Helper ---
        const grid = new THREE.GridHelper(200, 20, 0x555555, 0x222222);
        grid.position.y = -19.9;
        scene.add(grid);

        // --- Lighting ---
        scene.add(new THREE.AmbientLight(0x404040, 1.5));
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(100, 200, 100);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);

        // --- Point Lights for dynamic lighting ---
        const pointLight1 = new THREE.PointLight(0xff00ff, 1, 100);
        pointLight1.position.set(0, 20, 0);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0x00ffff, 1, 100);
        pointLight2.position.set(30, 20, 30);
        scene.add(pointLight2);

        // --- Interaction Setup ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isTouchDevice = false;

        function handleInteraction(clientX, clientY) {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects([groundMesh, ...objects.map(o => o.mesh)]);
            if (intersects.length > 0) {
                const point = intersects[0].point;
                createSelectedObject(point.x, point.y + 10, point.z);
            }
        }

        // Mouse events
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        
        function onMouseDown(event) {
            if (event.button === 0) { // Left mouse button
                handleInteraction(event.clientX, event.clientY);
            }
        }
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mousedown', onMouseDown);

        // Touch events
        function onTouchStart(event) {
            isTouchDevice = true;
            event.preventDefault();
            const touch = event.touches[0];
            handleInteraction(touch.clientX, touch.clientY);
        }
        
        function onTouchMove(event) {
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            }
            event.preventDefault();
        }
        
        window.addEventListener('touchstart', onTouchStart, { passive: false });
        window.addEventListener('touchmove', onTouchMove, { passive: false });

        // --- Central Structure ---
        const centralStructure = new THREE.Group();
        scene.add(centralStructure);
        
        const centralGeometry = new THREE.SphereGeometry(5, 32, 32);
        const centralMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x444444, 
            emissive: 0x222222,
            roughness: 0.3,
            metalness: 0.8,
            wireframe: false
        });
        const centralMesh = new THREE.Mesh(centralGeometry, centralMaterial);
        centralMesh.castShadow = true;
        centralMesh.receiveShadow = true;
        centralStructure.add(centralMesh);
        
        const centralStructureBody = new CANNON.Body({ 
            mass: 0,
            shape: new CANNON.Sphere(5),
            position: new CANNON.Vec3(0, 0, 0)
        });
        world.addBody(centralStructureBody);

        // --- Object Creation ---
        const objects = [];
        const attachedObjects = [];
        const attachmentDistance = 15;
        
        // Model cache
        const modelCache = {};
        
        function getColorByMode(mode, index, distance) {
            switch(mode) {
                case 'gradient':
                    return new THREE.Color().setHSL(index * 0.1 % 1, 0.7, 0.5);
                case 'distance':
                    return new THREE.Color().setHSL(Math.min(distance / 100, 1), 0.7, 0.5);
                case 'random':
                default:
                    return new THREE.Color(Math.random() * 0xffffff);
            }
        }

        // Load a GLTF model
        async function loadModel(url) {
            if (modelCache[url]) return modelCache[url];
            
            return new Promise((resolve) => {
                const loader = new THREE.GLTFLoader();
                loader.load(url, (gltf) => {
                    modelCache[url] = gltf.scene;
                    resolve(gltf.scene);
                }, undefined, (error) => {
                    console.error('Error loading model:', error);
                    // Fallback to a simple sphere if model fails to load
                    const sphere = new THREE.Mesh(
                        new THREE.SphereGeometry(1),
                        new THREE.MeshStandardMaterial({ color: 0xff0000 })
                    );
                    modelCache[url] = sphere;
                    resolve(sphere);
                });
            });
        }

        // Object presets with models and physics shapes
        const objectPresets = {
            square: {
                create: async () => {
                    const geometry = new THREE.BoxGeometry(3*params.objectSize, 3*params.objectSize, 3*params.objectSize);
                    const color = getColorByMode(params.colorMode, objects.length, 0);
                    const material = new THREE.MeshStandardMaterial({ 
                        color: color,
                        emissive: color.clone().multiplyScalar(0.5),
                        emissiveIntensity: 0.5,
                        roughness: 0.4,
                        metalness: 0.6
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    return {
                        mesh,
                        shape: new CANNON.Box(new CANNON.Vec3(1.5*params.objectSize, 1.5*params.objectSize, 1.5*params.objectSize))
                    };
                }
            },
            triangle: {
                create: async () => {
                    const geometry = new THREE.ConeGeometry(2*params.objectSize, 3*params.objectSize, 3);
                    const color = getColorByMode(params.colorMode, objects.length, 0);
                    const material = new THREE.MeshStandardMaterial({ 
                        color: color,
                        emissive: color.clone().multiplyScalar(0.5),
                        emissiveIntensity: 0.5,
                        roughness: 0.4,
                        metalness: 0.6
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    return {
                        mesh,
                        shape: new CANNON.Cylinder(2*params.objectSize, 0, 3*params.objectSize, 3)
                    };
                }
            },
            orb: {
                create: async () => {
                    const geometry = new THREE.SphereGeometry(2*params.objectSize, 32, 32);
                    const color = getColorByMode(params.colorMode, objects.length, 0);
                    const material = new THREE.MeshStandardMaterial({ 
                        color: color,
                        emissive: color.clone().multiplyScalar(0.5),
                        emissiveIntensity: 0.5,
                        roughness: 0.4,
                        metalness: 0.6
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    return {
                        mesh,
                        shape: new CANNON.Sphere(2*params.objectSize)
                    };
                }
            },
            plane: {
                create: async () => {
                    const geometry = new THREE.PlaneGeometry(4*params.objectSize, 4*params.objectSize);
                    geometry.rotateX(-Math.PI / 2);
                    const color = getColorByMode(params.colorMode, objects.length, 0);
                    const material = new THREE.MeshStandardMaterial({ 
                        color: color,
                        emissive: color.clone().multiplyScalar(0.5),
                        emissiveIntensity: 0.5,
                        roughness: 0.4,
                        metalness: 0.6,
                        side: THREE.DoubleSide
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    return {
                        mesh,
                        shape: new CANNON.Box(new CANNON.Vec3(2*params.objectSize, 0.1, 2*params.objectSize))
                    };
                }
            },
            star: {
                create: async () => {
                    // Create a star shape
                    const starShape = new THREE.Shape();
                    const spikes = 5;
                    const outerRadius = 2 * params.objectSize;
                    const innerRadius = outerRadius * 0.5;
                    
                    starShape.moveTo(outerRadius, 0);
                    for (let i = 0; i < spikes * 2; i++) {
                        const radius = i % 2 === 0 ? outerRadius : innerRadius;
                        const angle = (i / spikes) * Math.PI;
                        starShape.lineTo(
                            Math.cos(angle) * radius,
                            Math.sin(angle) * radius
                        );
                    }
                    starShape.lineTo(outerRadius, 0);
                    
                    const extrudeSettings = {
                        steps: 1,
                        depth: 0.5 * params.objectSize,
                        bevelEnabled: true,
                        bevelThickness: 0.1,
                        bevelSize: 0.1,
                        bevelOffset: 0,
                        bevelSegments: 1
                    };
                    
                    const geometry = new THREE.ExtrudeGeometry(starShape, extrudeSettings);
                    const color = getColorByMode(params.colorMode, objects.length, 0);
                    const material = new THREE.MeshStandardMaterial({ 
                        color: color,
                        emissive: color.clone().multiplyScalar(0.5),
                        emissiveIntensity: 0.5,
                        roughness: 0.4,
                        metalness: 0.6
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    // For physics, we'll use a compound shape that approximates the star
                    const starShapePhysics = new CANNON.Compound();
                    
                    // Center box
                    starShapePhysics.addShape(
                        new CANNON.Box(new CANNON.Vec3(innerRadius * 0.7, 0.25 * params.objectSize, innerRadius * 0.7))
                    );
                    
                    // Spikes (as boxes)
                    for (let i = 0; i < spikes; i++) {
                        const angle = (i / spikes) * 2 * Math.PI;
                        const x = Math.cos(angle) * (outerRadius + innerRadius) / 2;
                        const z = Math.sin(angle) * (outerRadius + innerRadius) / 2;
                        
                        starShapePhysics.addShape(
                            new CANNON.Box(new CANNON.Vec3(
                                (outerRadius - innerRadius) / 2,
                                0.25 * params.objectSize,
                                0.2 * params.objectSize
                            )),
                            new CANNON.Vec3(x, 0, z),
                            new CANNON.Quaternion().setFromAxisAngle(
                                new CANNON.Vec3(0, 1, 0),
                                angle
                            )
                        );
                    }
                    
                    return {
                        mesh,
                        shape: starShapePhysics
                    };
                }
            },
            cat: {
                create: async () => {
                    // Simple cat model (using a placeholder - in a real app you'd use an actual cat model)
                    const catModel = await loadModel('https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/models/gltf/LittlestTokyo.glb');
                    catModel.scale.set(params.objectSize, params.objectSize, params.objectSize);
                    catModel.traverse(child => {
                        if (child.isMesh) {
                            const color = getColorByMode(params.colorMode, objects.length, 0);
                            child.material = new THREE.MeshStandardMaterial({ 
                                color: color,
                                emissive: color.clone().multiplyScalar(0.5),
                                emissiveIntensity: 0.5,
                                roughness: 0.4,
                                metalness: 0.6
                            });
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    return {
                        mesh: catModel,
                        shape: new CANNON.Box(new CANNON.Vec3(1.5*params.objectSize, 1.5*params.objectSize, 1.5*params.objectSize))
                    };
                }
            },
            dog: {
                create: async () => {
                    // Simple dog model (using a placeholder - in a real app you'd use an actual dog model)
                    const dogModel = await loadModel('https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/models/gltf/LittlestTokyo.glb');
                    dogModel.scale.set(params.objectSize, params.objectSize, params.objectSize);
                    dogModel.traverse(child => {
                        if (child.isMesh) {
                            const color = getColorByMode(params.colorMode, objects.length, 0);
                            child.material = new THREE.MeshStandardMaterial({ 
                                color: color,
                                emissive: color.clone().multiplyScalar(0.5),
                                emissiveIntensity: 0.5,
                                roughness: 0.4,
                                metalness: 0.6
                            });
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    return {
                        mesh: dogModel,
                        shape: new CANNON.Box(new CANNON.Vec3(1.5*params.objectSize, 1.5*params.objectSize, 1.5*params.objectSize))
                    };
                }
            }
        };

        async function createSelectedObject(x = (Math.random()-0.5)*100, y = Math.random() * 60 + 20, z = (Math.random()-0.5)*100) {
            const preset = objectPresets[params.selectedObject] || objectPresets.square;
            
            // Create the object
            const { mesh, shape } = await preset.create();
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // Create physics body
            let mass = Math.random() * 5 + 2;
            
            if (params.strangePhysics) {
                mass = Math.random() * 50 + 5; // Heavier objects
                if (shape instanceof CANNON.Sphere) shape.radius *= 1.5;
                if (shape instanceof CANNON.Box) shape.halfExtents.scale(1.5, new CANNON.Vec3());
            }
            
            const body = new CANNON.Body({ mass, shape, material: defaultMaterial });
            body.position.copy(mesh.position);
            
            // Apply initial velocity
            if (params.strangePhysics) {
                body.velocity.set(
                    (Math.random()-0.5)*50, 
                    (Math.random()-0.5)*50, 
                    (Math.random()-0.5)*50
                );
                body.angularVelocity.set(
                    Math.random()*10,
                    Math.random()*10,
                    Math.random()*10
                );
            } else {
                body.velocity.set(
                    (Math.random()-0.5)*20, 
                    (Math.random()-0.5)*20, 
                    (Math.random()-0.5)*20
                );
            }
            
            world.addBody(body);
            
            const newObject = { mesh, body, attachedTime: null };
            objects.push(newObject);
            
            return newObject;
        }

        // Create initial objects
        const NUM_OBJECTS = 20;
        async function createInitialObjects() {
            for (let i = 0; i < NUM_OBJECTS; i++) {
                await createSelectedObject();
            }
        }
        createInitialObjects();

        // --- Particle System for Ambient Effects ---
        const particleCount = 3000;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleSizes = new Float32Array(particleCount);
        
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            particlePositions[i3] = (Math.random() - 0.5) * 400;
            particlePositions[i3 + 1] = (Math.random() - 0.5) * 400;
            particlePositions[i3 + 2] = (Math.random() - 0.5) * 400;
            particleSizes[i] = Math.random() * 2;
        }
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
        
        const particleMaterial = new THREE.PointsMaterial({
            size: 1,
            color: 0xffffff,
            transparent: true,
            opacity: 0.5,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });
        
        const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particleSystem);

        // --- Helpers ---
        function explodeStructure() {
            // Apply outward forces to all objects
            [...objects, ...attachedObjects].forEach(obj => {
                const direction = new CANNON.Vec3().copy(obj.body.position).unit();
                const force = direction.scale(params.explodeForce * obj.body.mass);
                obj.body.applyImpulse(force, obj.body.position);
            });
        }

        async function resetScene() {
            // Remove all objects
            [...objects, ...attachedObjects].forEach(obj => {
                scene.remove(obj.mesh);
                world.removeBody(obj.body);
            });
            
            objects.length = 0;
            attachedObjects.length = 0;
            
            // Create new objects
            for (let i = 0; i < NUM_OBJECTS; i++) {
                await createSelectedObject();
            }
        }

        // --- UI Controls ---
        document.getElementById('gravity').addEventListener('input', (e) => {
            params.gravity = parseFloat(e.target.value);
            world.gravity.set(0, -params.gravity, 0);
        });
        
        document.getElementById('attraction').addEventListener('input', (e) => {
            params.attractionForce = parseFloat(e.target.value);
        });
        
        document.getElementById('colorMode').addEventListener('change', (e) => {
            params.colorMode = e.target.value;
        });
        
        document.getElementById('objectType').addEventListener('change', (e) => {
            params.selectedObject = e.target.value;
        });
        
        document.getElementById('objectSize').addEventListener('input', (e) => {
            params.objectSize = parseFloat(e.target.value);
        });
        
        document.getElementById('strangePhysics').addEventListener('change', (e) => {
            params.strangePhysics = e.target.checked;
        });
        
        document.getElementById('explodeBtn').addEventListener('click', explodeStructure);
        document.getElementById('resetBtn').addEventListener('click', resetScene);

        // Toggle controls panel
        document.querySelector('.toggle-controls').addEventListener('click', () => {
            document.querySelector('.control-panel').classList.toggle('collapsed');
        });

        // Hide info panel after 5 seconds
        setTimeout(() => {
            document.getElementById('info').style.opacity = '0';
        }, 5000);

        // --- Animation Loop ---
        let lastTime;
        let elapsedTime = 0;
        
        function animate(time) {
            requestAnimationFrame(animate);
            
            if (lastTime !== undefined) {
                const dt = Math.min((time - lastTime) / 1000, 0.1); // Cap at 0.1 to avoid large jumps
                world.step(1/60, dt, 3);
                elapsedTime += dt;
            }
            lastTime = time;

            // Update camera position if auto-rotate is enabled
            if (orbitControls.autoRotate) {
                orbitControls.theta += orbitControls.autoRotateSpeed * 0.01;
                camera.position.x = orbitControls.radius * Math.sin(orbitControls.theta) * Math.cos(orbitControls.phi);
                camera.position.z = orbitControls.radius * Math.cos(orbitControls.theta) * Math.cos(orbitControls.phi);
                camera.position.y = orbitControls.radius * Math.sin(orbitControls.phi);
                camera.lookAt(orbitControls.target);
            }

            // Update dynamic objects
            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i];
                const objPosition = obj.body.position;
                const distanceToCenter = Math.sqrt(
                    objPosition.x * objPosition.x + 
                    objPosition.y * objPosition.y + 
                    objPosition.z * objPosition.z
                );

                // Attraction to the center
                const directionToCenter = new CANNON.Vec3(
                    -objPosition.x / distanceToCenter,
                    -objPosition.y / distanceToCenter,
                    -objPosition.z / distanceToCenter
                );
                const force = directionToCenter.scale(params.attractionForce);
                obj.body.applyForce(force, new CANNON.Vec3());

                // Check for attachment to the central structure
                if (distanceToCenter < attachmentDistance && !obj.attachedTime) {
                    obj.attachedTime = elapsedTime;
                    attachedObjects.push(obj);
                    objects.splice(i, 1); // Remove from active objects

                    // Create a constraint to the central structure
                    const constraint = new CANNON.PointToPointConstraint(
                        centralStructureBody,
                        new CANNON.Vec3(objPosition.x, objPosition.y, objPosition.z),
                        obj.body,
                        new CANNON.Vec3(0, 0, 0)
                    );
                    world.addConstraint(constraint);
                    
                    // Visual effect for attachment
                    const flash = new THREE.PointLight(0xffffff, 5, 20);
                    flash.position.copy(obj.mesh.position);
                    scene.add(flash);
                    setTimeout(() => scene.remove(flash), 300);
                } else if (!obj.attachedTime) {
                    // Update position and rotation for free-floating objects
                    obj.mesh.position.copy(obj.body.position);
                    obj.mesh.quaternion.copy(obj.body.quaternion);
                }
            }

            // Update all attached objects
            attachedObjects.forEach(obj => {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
                
                // Pulse effect based on time since attachment
                if (obj.attachedTime) {
                    const timeSinceAttachment = elapsedTime - obj.attachedTime;
                    const pulseIntensity = Math.sin(timeSinceAttachment * 2) * 0.2 + 0.8;
                    
                    if (obj.mesh.material) {
                        obj.mesh.material.emissiveIntensity = pulseIntensity * params.pulseIntensity;
                    }
                }
            });

            // Update central mesh rotation
            centralMesh.rotation.y += 0.01;
            centralMesh.rotation.z += 0.005;

            // Update dynamic lighting
            pointLight1.position.x = Math.sin(elapsedTime) * 30;
            pointLight1.position.z = Math.cos(elapsedTime) * 30;
            pointLight2.position.x = Math.sin(elapsedTime + Math.PI) * 30;
            pointLight2.position.z = Math.cos(elapsedTime + Math.PI) * 30;

            // Update particles (subtle movement)
            const positions = particleGeometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                positions[i3 + 1] += Math.sin(elapsedTime + i) * 0.02;
                
                // Wrap particles if they go too far
                if (Math.abs(positions[i3]) > 200) positions[i3] *= -0.9;
                if (Math.abs(positions[i3 + 1]) > 200) positions[i3 + 1] *= -0.9;
                if (Math.abs(positions[i3 + 2]) > 200) positions[i3 + 2] *= -0.9;
            }
            particleGeometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }
        
        requestAnimationFrame(animate);

        // --- Window Resize Handler ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
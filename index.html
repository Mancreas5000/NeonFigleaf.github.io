<!DOCTYPE html>
<html>
<head>
    <title>COSMIC SPIDER: INFINITE ASCENSION</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
            cursor: crosshair;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: 'Courier New', monospace;
            pointer-events: none;
            text-shadow: 0 0 10px #0ff;
        }
        #score {
            font-size: 18px;
            color: #0ff;
            margin-bottom: 10px;
        }
        #energy {
            width: 200px;
            height: 10px;
            background: rgba(0, 100, 255, 0.3);
            margin: 5px 0;
            border-radius: 5px;
            overflow: hidden;
        }
        #energy-bar {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #00f7ff, #ff00f7);
            transition: width 0.1s;
        }
        #powers {
            margin-top: 15px;
        }
        .power {
            display: inline-block;
            margin-right: 15px;
            font-size: 14px;
            opacity: 0.7;
        }
        .power.active {
            opacity: 1;
            text-shadow: 0 0 10px currentColor;
        }
        #inventory {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-family: 'Courier New', monospace;
            pointer-events: none;
            text-shadow: 0 0 10px #0ff;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            max-width: 200px;
        }
        #upgrade-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 50, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #0ff;
            display: none;
            z-index: 100;
            font-family: 'Courier New', monospace;
            max-width: 400px;
        }
        .upgrade-option {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #0ff;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .upgrade-option:hover {
            background: rgba(0, 200, 255, 0.2);
        }
        .upgrade-cost {
            color: #ff0;
            font-size: 0.9em;
        }
        #controls-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #aaa;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            pointer-events: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="loading">LOADING COSMIC REALM...</div>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div id="score">>> SCORE: 0</div>
        <div>ENERGY: <span id="energy-value">100%</span></div>
        <div id="energy"><div id="energy-bar"></div></div>
        <div id="powers">
            <div class="power" id="power-time">‚è≥ TIME BEND [1]</div>
            <div class="power" id="power-phase">üëª PHASE SHIFT [2]</div>
            <div class="power" id="power-clone">üîÑ QUANTUM CLONE [3]</div>
        </div>
    </div>

    <div id="inventory">
        <h3>INVENTORY</h3>
        <div id="fragments">QUANTUM FRAGMENTS: 0</div>
        <div id="cores">NEBULA CORES: 0</div>
        <div id="seeds">BLACK HOLE SEEDS: 0</div>
        <div style="margin-top: 10px; font-size: 12px; color: #aaa;">Press [I] to upgrade</div>
    </div>

    <div id="upgrade-menu">
        <h2>SHIP UPGRADES</h2>
        <div class="upgrade-option" onclick="purchaseUpgrade('tractor')">
            <strong>QUANTUM TRACTOR ARRAY</strong><br>
            Shoot 5 tractor beams in all directions<br>
            <span class="upgrade-cost">Cost: 5 Quantum Fragments</span>
        </div>
        <div class="upgrade-option" onclick="purchaseUpgrade('color')">
            <strong>CHROMATIC SHIFT</strong><br>
            Change ship color to random cosmic hues<br>
            <span class="upgrade-cost">Cost: 3 Nebula Cores</span>
        </div>
        <div class="upgrade-option" onclick="purchaseUpgrade('gravity')">
            <strong>ANTI-GRAVITY BOOSTERS</strong><br>
            Reduce gravity by 50%<br>
            <span class="upgrade-cost">Cost: 2 Black Hole Seeds</span>
        </div>
        <div class="upgrade-option" onclick="purchaseUpgrade('size')">
            <strong>MASSIVE FORM</strong><br>
            Become a giant cosmic spider<br>
            <span class="upgrade-cost">Cost: 10 of each resource</span>
        </div>
        <div style="margin-top: 15px; text-align: center;">
            <button onclick="closeUpgradeMenu()" style="padding: 5px 15px; background: #0ff; border: none; border-radius: 3px; cursor: pointer;">Close</button>
        </div>
    </div>

    <div id="controls-info">
        MOUSE: Aim direction | LMB: Forward | RMB: Backward<br>
        KEYS: [A]/[D] Rotate | [W] Forward | [S] Backward | [E] Tractor<br>
        [1-3] Powers | [M] Music | [I] Inventory
    </div>

    <audio id="music" loop>
        <!-- Music will be loaded dynamically -->
    </audio>

    <script>
        // ======== GAME INITIALIZATION ========
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const loadingScreen = document.getElementById('loading');
        const scoreDisplay = document.getElementById('score');
        const energyBar = document.getElementById('energy-bar');
        const energyValue = document.getElementById('energy-value');
        const powerDisplays = {
            time: document.getElementById('power-time'),
            phase: document.getElementById('power-phase'),
            clone: document.getElementById('power-clone')
        };
        const music = document.getElementById('music');
        const inventoryDisplay = {
            fragments: document.getElementById('fragments'),
            cores: document.getElementById('cores'),
            seeds: document.getElementById('seeds')
        };
        const upgradeMenu = document.getElementById('upgrade-menu');

        // Canvas setup
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        let width = canvas.width;
        let height = canvas.height;

        // ======== GAME STATE ========
        let score = 0;
        let energy = 100;
        let tractorBeamActiveTime = 0;
        let isTractorBeamActive = false;
        let isTractorBeamRetracting = false;
        let tractorBeamAngle = 0;
        let tractorBeamPower = 0;
        let cosmicEnergy = 0;
        let blackHoles = [];
        let timeSlow = 1;
        let isPhasing = false;
        let clones = [];
        let gameTime = 0;
        let level = 1;
        let mouseX = width / 2;
        let mouseY = height / 2;
        let isMouseForward = false;
        let isMouseBackward = false;
        
        // Camera system for infinite world
        let cameraX = 0;
        let cameraY = 0;
        const worldWidth = 10000;  // Large world size
        const worldHeight = 10000;
        const viewportPadding = 500; // Area around viewport where objects are active
        
        // Control state flags
        let isRotatingLeft = false;
        let isRotatingRight = false;
        let isThrusting = false;
        let isReversing = false;
        
        // Inventory
        let inventory = {
            fragments: 0,
            cores: 0,
            seeds: 0
        };

        // Upgrades
        let upgrades = {
            tractor: false,
            color: false,
            gravity: false,
            size: false
        };

        // Ship colors
        const shipColors = [
            { primary: '#00f7ff', secondary: '#ff00f7' },
            { primary: '#ff00f7', secondary: '#00f7ff' },
            { primary: '#00ff88', secondary: '#8800ff' },
            { primary: '#ff8800', secondary: '#0088ff' },
            { primary: '#ffff00', secondary: '#ff00ff' }
        ];
        let currentColorIndex = 0;

        // ======== WORLD OBJECTS ========
        let steps = [];
        let objects = [];
        let activeObjects = []; // Objects currently in viewport
        
        // Object pools for performance
        const stepPool = [];
        const objectPool = [];
        const blackHolePool = [];
        const clonePool = [];

        // ======== SPIDER ========
        const spider = {
            x: worldWidth / 2,
            y: worldHeight / 2,
            radius: 20,
            vx: 0,
            vy: 0,
            angle: -Math.PI / 2,
            rotationSpeed: 0.08,
            thrustPower: 0.3,
            thrustEnergyCost: 0.2,
            drag: 0.99,
            bounceFactor: 0.6,
            gravity: 0.05,
            baseRadius: 20,

            draw() {
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.angle + Math.PI / 2);

                const colors = shipColors[currentColorIndex];

                // Glowing core
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 1.3, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 200, 255, ${isPhasing ? 0.3 : 0.7})`;
                ctx.shadowBlur = 30;
                ctx.shadowColor = colors.primary;
                ctx.fill();

                // Spider body
                if (!isPhasing) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
                    gradient.addColorStop(0, colors.primary);
                    gradient.addColorStop(1, colors.secondary);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }

                // Beak
                if (!isPhasing) {
                    ctx.beginPath();
                    ctx.moveTo(this.radius * 1.2, 0);
                    ctx.lineTo(this.radius * 0.6, -this.radius * 0.4);
                    ctx.lineTo(this.radius * 0.6, this.radius * 0.4);
                    ctx.closePath();
                    const beakGradient = ctx.createLinearGradient(
                        this.radius * 0.6, 0,
                        this.radius * 1.2, 0
                    );
                    beakGradient.addColorStop(0, colors.primary);
                    beakGradient.addColorStop(1, '#000');
                    ctx.fillStyle = beakGradient;
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(this.radius * 0.8, -this.radius * 0.2);
                    ctx.lineTo(this.radius * 0.9, 0);
                    ctx.lineTo(this.radius * 0.8, this.radius * 0.2);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Legs
                const legBaseAngle = -Math.PI / 2;
                for (let i = 0; i < 8; i++) {
                    const angleOffset = (i / 8) * Math.PI * 2 + gameTime * 2;
                    const legLength = 30 + Math.sin(gameTime * 3 + i) * 15;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(
                        Math.cos(angleOffset + legBaseAngle) * legLength,
                        Math.sin(angleOffset + legBaseAngle) * legLength
                    );
                    ctx.strokeStyle = `rgba(0, ${200 + Math.sin(gameTime + i) * 55}, 255, 0.7)`;
                    ctx.lineWidth = 2 + Math.sin(gameTime * 2 + i);
                    ctx.stroke();
                }

                ctx.restore();
                ctx.shadowBlur = 0;

                // Tractor beam
                if ((isTractorBeamActive || isTractorBeamRetracting) && tractorBeamPower > 0.01) {
                    if (upgrades.tractor) {
                        for (let i = 0; i < 5; i++) {
                            const angle = tractorBeamAngle + (i - 2) * Math.PI / 6;
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY);
                            const beamLength = 300 * tractorBeamPower + Math.sin(gameTime * 5) * 50;
                            ctx.lineTo(
                                screenX + Math.cos(angle) * beamLength,
                                screenY + Math.sin(angle) * beamLength
                            );
                            ctx.strokeStyle = `rgba(0, 255, 255, ${tractorBeamPower * 0.7})`;
                            ctx.lineWidth = 5 * tractorBeamPower;
                            ctx.shadowBlur = 20 * tractorBeamPower;
                            ctx.shadowColor = colors.primary;
                            ctx.stroke();
                        }
                    } else {
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY);
                        const beamLength = 500 * tractorBeamPower + Math.sin(gameTime * 5) * 330;
                        ctx.lineTo(
                            screenX + Math.cos(tractorBeamAngle) * beamLength,
                            screenY + Math.sin(tractorBeamAngle) * beamLength
                        );
                        ctx.strokeStyle = `rgba(0, 255, 255, ${tractorBeamPower * 0.7})`;
                        ctx.lineWidth = 5 * tractorBeamPower;
                        ctx.shadowBlur = 20 * tractorBeamPower;
                        ctx.shadowColor = colors.primary;
                        ctx.stroke();
                    }
                    ctx.shadowBlur = 0;
                }
            },
            
            update() {
                const currentGravity = upgrades.gravity ? this.gravity * 0.5 : this.gravity;
                this.radius = upgrades.size ? this.baseRadius * 2 : this.baseRadius;

                // Mouse aiming
                const dx = mouseX - (this.x - cameraX);
                const dy = mouseY - (this.y - cameraY);
                const targetAngle = Math.atan2(dy, dx);

                let angleDiff = targetAngle - this.angle;
                if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                const mouseDist = Math.sqrt(dx * dx + dy * dy);
                if (mouseDist > 20) {
                    this.angle += angleDiff * 0.1 * timeSlow;
                }

                // Rotation controls
                if (isRotatingLeft) {
                    this.angle -= this.rotationSpeed * timeSlow;
                }
                if (isRotatingRight) {
                    this.angle += this.rotationSpeed * timeSlow;
                }

                // Movement controls
                if ((isThrusting || isMouseForward) && energy > 0 && !isPhasing) {
                    const thrustX = Math.cos(this.angle) * this.thrustPower * timeSlow;
                    const thrustY = Math.sin(this.angle) * this.thrustPower * timeSlow;
                    this.vx += thrustX;
                    this.vy += thrustY;
                    energy -= this.thrustEnergyCost * timeSlow;
                }

                if ((isReversing || isMouseBackward) && energy > 0 && !isPhasing) {
                    const thrustX = Math.cos(this.angle) * this.thrustPower * timeSlow * -0.7;
                    const thrustY = Math.sin(this.angle) * this.thrustPower * timeSlow * -0.7;
                    this.vx += thrustX;
                    this.vy += thrustY;
                    energy -= this.thrustEnergyCost * timeSlow * 0.7;
                }

                // Apply physics
                this.vx *= this.drag;
                this.vy *= this.drag;

                if (!isPhasing) {
                    this.vy += currentGravity * timeSlow;
                }

                // Black hole gravity
                blackHoles.forEach(hole => {
                    const dx = hole.x - this.x;
                    const dy = hole.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < hole.radius * 3 && dist > 1) {
                        const force = (hole.radius * 10) / (dist * dist);
                        this.vx += (dx / dist) * force * 0.05 * timeSlow;
                        this.vy += (dy / dist) * force * 0.05 * timeSlow;
                    } else if (dist <= spider.radius + hole.radius) {
                        // Teleport to center if caught by black hole
                        this.x = worldWidth / 2;
                        this.y = worldHeight / 2;
                        this.vx = 0;
                        this.vy = 0;
                        cameraX = this.x - width / 2;
                        cameraY = this.y - height / 2;
                    }
                });

                // Update position
                this.x += this.vx * timeSlow;
                this.y += this.vy * timeSlow;

                // World boundaries
                if (!isPhasing) {
                    if (this.x < this.radius) {
                        this.x = this.radius;
                        this.vx *= -this.bounceFactor;
                    }
                    if (this.x > worldWidth - this.radius) {
                        this.x = worldWidth - this.radius;
                        this.vx *= -this.bounceFactor;
                    }
                    if (this.y < this.radius) {
                        this.y = this.radius;
                        this.vy *= -this.bounceFactor;
                    }
                    if (this.y > worldHeight - this.radius) {
                        this.y = worldHeight - this.radius;
                        this.vy *= -this.bounceFactor;
                    }
                } else {
                    // Wrap around when phasing
                    if (this.x < -this.radius) this.x = worldWidth + this.radius;
                    if (this.x > worldWidth + this.radius) this.x = -this.radius;
                    if (this.y < -this.radius) this.y = worldHeight + this.radius;
                    if (this.y > worldHeight + this.radius) this.y = -this.radius;
                }

                // Update camera to follow spider
                cameraX = this.x - width / 2;
                cameraY = this.y - height / 2;
                
                // Clamp camera to world bounds
                cameraX = Math.max(0, Math.min(worldWidth - width, cameraX));
                cameraY = Math.max(0, Math.min(worldHeight - height, cameraY));
            }
        };

        // ======== WORLD GENERATION ========
        function generateInitialWorld() {
            // Generate initial platforms around the starting area
            for (let y = spider.y - height; y < spider.y + height * 2; y += 100) {
                for (let i = 0; i < 3; i++) {
                    const x = spider.x - width + Math.random() * width * 2;
                    if (y > spider.y + height / 2 || Math.random() > 0.7) {
                        createStep(x, y, 100 + Math.random() * 100, 10);
                    }
                }
            }
            
            // Generate initial objects
            for (let i = 0; i < 50; i++) {
                const type = Math.random() < 0.4 ? 0 : (Math.random() < 0.7 ? 1 : 2);
                const x = spider.x - width + Math.random() * width * 2;
                const y = spider.y - height + Math.random() * height * 2;
                createObject(x, y, type);
            }
        }

        // ======== OBJECT POOLING ========
        function createStep(x, y, width, height) {
            let step;
            if (stepPool.length > 0) {
                step = stepPool.pop();
                step.x = x;
                step.y = y;
                step.width = width;
                step.height = height;
            } else {
                step = new Step(x, y, width, height);
            }
            steps.push(step);
            return step;
        }

        function createObject(x, y, type) {
            let obj;
            if (objectPool.length > 0) {
                obj = objectPool.pop();
                Object.assign(obj, new CosmicObject(x, y, type));
            } else {
                obj = new CosmicObject(x, y, type);
            }
            objects.push(obj);
            return obj;
        }

        function createBlackHole(x, y) {
            let hole;
            if (blackHolePool.length > 0) {
                hole = blackHolePool.pop();
                Object.assign(hole, new BlackHole(x, y));
            } else {
                hole = new BlackHole(x, y);
            }
            blackHoles.push(hole);
            return hole;
        }

        function createClone(x, y) {
            let clone;
            if (clonePool.length > 0) {
                clone = clonePool.pop();
                clone.x = x;
                clone.y = y;
                clone.lifetime = 300;
                clone.alpha = 1;
            } else {
                clone = new Clone(x, y);
            }
            clones.push(clone);
            return clone;
        }

        // ======== GAME OBJECT CLASSES ========
        class Step {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }
            draw() {
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Only draw if in viewport
                if (screenX + this.width/2 < 0 || screenX - this.width/2 > width ||
                    screenY + this.height/2 < 0 || screenY - this.height/2 > height) {
                    return;
                }
                
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.fillStyle = 'rgba(0, 200, 255, 0.5)';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#0ff';
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.shadowBlur = 0;
                ctx.restore();
            }
            
            isInViewport() {
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                return screenX + this.width/2 > -viewportPadding && 
                       screenX - this.width/2 < width + viewportPadding &&
                       screenY + this.height/2 > -viewportPadding && 
                       screenY - this.height/2 < height + viewportPadding;
            }
        }

        class CosmicObject {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = (type === 2 ? 25 + Math.random() * 10 : 10 + Math.random() * 10) * 3;
                this.vx = Math.random() * 2 - 1;
                this.vy = Math.random() * 2 - 1;
                this.collected = false;
                this.time = Math.random() * 100;
                this.pulseSpeed = 0.05 + Math.random() * 0.05;
                this.color = objectTypes[type].colors[Math.floor(Math.random() * objectTypes[type].colors.length)];
                this.shape = objectTypes[type].shapes[Math.floor(Math.random() * objectTypes[type].shapes.length)];
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.1;
                this.scale = 0.8 + Math.random() * 0.4;
            }
            
            update() {
                this.time += this.pulseSpeed * timeSlow;
                this.rotation += this.rotationSpeed * timeSlow;
                this.x += this.vx * timeSlow;
                this.y += this.vy * timeSlow;

                // World boundaries
                if (this.x < this.radius) {
                    this.x = this.radius;
                    this.vx *= -1;
                }
                if (this.x > worldWidth - this.radius) {
                    this.x = worldWidth - this.radius;
                    this.vx *= -1;
                }
                if (this.y < this.radius) {
                    this.y = this.radius;
                    this.vy *= -1;
                }
                if (this.y > worldHeight - this.radius) {
                    this.y = worldHeight - this.radius;
                    this.vy *= -1;
                }

                // Black hole gravity
                blackHoles.forEach(hole => {
                    const dx = hole.x - this.x;
                    const dy = hole.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < hole.radius * 30 && dist > 1) {
                        const force = (hole.radius * 20) / (dist * dist);
                        this.vx += (dx / dist) * force * 0.08 * timeSlow;
                        this.vy += (dy / dist) * force * 0.03 * timeSlow;
                        if (dist < hole.radius * 1.5) {
                            // Teleport object if it gets too close to black hole
                            this.x = spider.x + (Math.random() * 200 - 100);
                            this.y = spider.y + (Math.random() * 200 - 100);
                            this.vx = Math.random() * 2 - 1;
                            this.vy = Math.random() * 2 - 1;
                        }
                    }
                });

                // Tractor beam effect
                if ((isTractorBeamActive || isTractorBeamRetracting) && tractorBeamPower > 0.1 && energy > 0) {
                    const dxBeam = this.x - spider.x;
                    const dyBeam = this.y - spider.y;
                    const distBeam = Math.sqrt(dxBeam * dxBeam + dyBeam * dyBeam);
                    
                    if (upgrades.tractor) {
                        for (let i = 0; i < 5; i++) {
                            const angle = tractorBeamAngle + (i - 2) * Math.PI / 6;
                            const angleToObject = Math.atan2(dyBeam, dxBeam);
                            const angleDiff = Math.abs(normalizeAngle(angleToObject - angle));
                            const angleThreshold = 0.5;
                            if (distBeam < 300 && distBeam > 1 && (angleDiff < angleThreshold || angleDiff > (2 * Math.PI - angleThreshold))) {
                                const force = (500 / distBeam) * tractorBeamPower;
                                this.vx -= (dxBeam / distBeam) * force * 0.01 * timeSlow;
                                this.vy -= (dyBeam / distBeam) * force * 0.01 * timeSlow;
                            }
                        }
                    } else {
                        const angleToObject = Math.atan2(dyBeam, dxBeam);
                        const angleDiff = Math.abs(normalizeAngle(angleToObject - tractorBeamAngle));
                        const angleThreshold = 4.5;
                        if (distBeam < 300 && distBeam > 1 && (angleDiff < angleThreshold || angleDiff > (2 * Math.PI - angleThreshold))) {
                            const force = (900 / distBeam) * tractorBeamPower;
                            this.vx -= (dxBeam / distBeam) * force * 0.01 * timeSlow;
                            this.vy -= (dyBeam / distBeam) * force * 0.01 * timeSlow;
                        }
                    }
                }
            }
            
            draw() {
                if (this.collected) return;
                
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Only draw if in viewport
                if (screenX + this.radius < 0 || screenX - this.radius > width ||
                    screenY + this.radius < 0 || screenY - this.radius > height) {
                    return;
                }
                
                if (this.type === 2) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.radius * (1.2 + Math.sin(this.time) * 0.3), 0, Math.PI * 2);
                    const gradient = ctx.createRadialGradient(
                        screenX, screenY, 0,
                        screenX, screenY, this.radius * 1.5
                    );
                    gradient.addColorStop(0, '#000');
                    gradient.addColorStop(0.7, this.color);
                    gradient.addColorStop(1, '#f00');
                    ctx.fillStyle = gradient;
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = this.color;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    return;
                }

                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.rotation);
                ctx.scale(this.scale, this.scale);

                const pulse = Math.sin(this.time) * 0.2 + 0.8;
                const size = this.radius * pulse;

                switch(this.shape) {
                    case 'circle':
                        ctx.beginPath();
                        ctx.arc(0, 0, size, 0, Math.PI * 2);
                        ctx.fillStyle = this.color;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = this.color;
                        ctx.fill();
                        break;
                    case 'triangle':
                        ctx.beginPath();
                        ctx.moveTo(0, -size);
                        ctx.lineTo(-size * 0.866, size * 0.5);
                        ctx.lineTo(size * 0.866, size * 0.5);
                        ctx.closePath();
                        ctx.fillStyle = this.color;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = this.color;
                        ctx.fill();
                        break;
                    // Other shapes remain the same as original...
                    default:
                        // Default to circle if shape not recognized
                        ctx.beginPath();
                        ctx.arc(0, 0, size, 0, Math.PI * 2);
                        ctx.fillStyle = this.color;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = this.color;
                        ctx.fill();
                }
                ctx.restore();
                ctx.shadowBlur = 0;
            }
            
            isInViewport() {
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                return screenX + this.radius > -viewportPadding && 
                       screenX - this.radius < width + viewportPadding &&
                       screenY + this.radius > -viewportPadding && 
                       screenY - this.radius < height + viewportPadding;
            }
        }

        class BlackHole {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.initialRadius = 30 + Math.random() * 20;
                this.radius = this.initialRadius;
                this.time = Math.random() * 100;
                this.pulseSpeed = 0.01 + Math.random() * 0.01;
                this.spinSpeed = 0.5 + Math.random();
                this.color1 = `hsl(${Math.random() * 60}, 100%, 50%)`;
                this.color2 = `hsl(${60 + Math.random() * 60}, 100%, 50%)`;
            }
            
            update() {
                this.time += this.pulseSpeed * timeSlow;
                this.radius = this.initialRadius + Math.sin(this.time) * 5;
            }
            
            draw() {
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Only draw if in viewport
                if (screenX + this.radius * 2 < 0 || screenX - this.radius * 2 > width ||
                    screenY + this.radius * 2 < 0 || screenY - this.radius * 2 > height) {
                    return;
                }
                
                ctx.save();
                ctx.translate(screenX, screenY);

                for (let i = 0; i < 3; i++) {
                    const ringRadius = this.radius * (1.5 + i * 0.5) + Math.sin(this.time * 2 + i) * 5;
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, ${100 + i * 50}, 0, 0.3)`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
                gradient.addColorStop(0, '#000');
                gradient.addColorStop(0.7, this.color1);
                gradient.addColorStop(1, this.color2);
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                ctx.rotate(this.time * this.spinSpeed);
                for (let i = 0; i < 12; i++) {
                    const distFromCenter = this.radius * (0.6 + Math.random() * 0.3);
                    const particleSize = 2 + Math.random() * 3;
                    ctx.beginPath();
                    ctx.arc(distFromCenter, 0, particleSize, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, 0.7)`;
                    ctx.fill();
                    ctx.rotate(Math.PI / 6);
                }
                ctx.restore();
            }
            
            isInViewport() {
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                return screenX + this.radius * 2 > -viewportPadding && 
                       screenX - this.radius * 2 < width + viewportPadding &&
                       screenY + this.radius * 2 > -viewportPadding && 
                       screenY - this.radius * 2 < height + viewportPadding;
            }
        }

        class Clone {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.lifetime = 300;
                this.alpha = 1;
            }
            
            update() {
                this.lifetime -= timeSlow;
                this.alpha = this.lifetime / 300;
                return this.lifetime > 0;
            }
            
            draw() {
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                ctx.globalAlpha = this.alpha * 0.5;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 15, 0, Math.PI * 2);
                ctx.fillStyle = '#0ff';
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // ======== GAME FUNCTIONS ========
        function normalizeAngle(angle) {
            angle = angle % (2 * Math.PI);
            if (angle < -Math.PI) angle += 2 * Math.PI;
            if (angle > Math.PI) angle -= 2 * Math.PI;
            return angle;
        }

        function spawnObjects() {
            // Calculate area around viewport where we want objects
            const minX = cameraX - viewportPadding;
            const maxX = cameraX + width + viewportPadding;
            const minY = cameraY - viewportPadding;
            const maxY = cameraY + height + viewportPadding;
            
            // Count existing objects in this area
            let existingObjects = objects.filter(obj => 
                !obj.collected && 
                obj.x >= minX && obj.x <= maxX &&
                obj.y >= minY && obj.y <= maxY
            ).length;
            
            const maxObjects = 20 + level * 5;
            
            // Spawn new objects if needed
            while (existingObjects < maxObjects) {
                const type = Math.random() < 0.4 ? 0 : (Math.random() < 0.7 ? 1 : 2);
                
                // Random position in padded viewport area
                let x, y;
                if (Math.random() > 0.5) {
                    // Spawn at edges
                    if (Math.random() > 0.5) {
                        x = Math.random() > 0.5 ? minX : maxX;
                        y = minY + Math.random() * (maxY - minY);
                    } else {
                        y = Math.random() > 0.5 ? minY : maxY;
                        x = minX + Math.random() * (maxX - minX);
                    }
                } else {
                    // Spawn randomly in area
                    x = minX + Math.random() * (maxX - minX);
                    y = minY + Math.random() * (maxY - minY);
                }
                
                // Clamp to world bounds
                x = Math.max(0, Math.min(worldWidth, x));
                y = Math.max(0, Math.min(worldHeight, y));
                
                createObject(x, y, type);
                existingObjects++;
            }
        }

        function spawnSteps() {
            // Calculate area around viewport where we want steps
            const minY = cameraY - viewportPadding;
            const maxY = cameraY + height + viewportPadding;
            
            // Count existing steps in this area
            let existingSteps = steps.filter(step => 
                step.y >= minY && step.y <= maxY
            ).length;
            
            const maxSteps = 30 + level * 10;
            
            // Spawn new steps if needed
            while (existingSteps < maxSteps) {
                const stepWidth = 100 + Math.random() * 100;
                const x = Math.random() * (worldWidth - stepWidth) + stepWidth/2;
                const y = minY + Math.random() * (maxY - minY);
                
                createStep(x, y, stepWidth, 10);
                existingSteps++;
            }
        }

        function checkCollisions() {
            objects.forEach((obj, index) => {
                if (obj.collected) return;
                
                const dx = spider.x - obj.x;
                const dy = spider.y - obj.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < spider.radius + obj.radius && !isPhasing) {
                    obj.collected = true;

                    if (obj.type === 0) inventory.fragments++;
                    else if (obj.type === 1) inventory.cores++;
                    else if (obj.type === 2) inventory.seeds++;

                    energy = Math.min(energy + objectTypes[obj.type].energy, 100);

                    updateInventoryDisplay();

                    if (obj.type === 2) {
                        createBlackHole(obj.x, obj.y);
                    } else {
                        cosmicEnergy += objectTypes[obj.type].value;
                    }
                }
            });

            // Remove collected objects from pool
            objects = objects.filter(obj => !obj.collected);
        }

        function updateInventoryDisplay() {
            inventoryDisplay.fragments.textContent = `QUANTUM FRAGMENTS: ${inventory.fragments}`;
            inventoryDisplay.cores.textContent = `NEBULA CORES: ${inventory.cores}`;
            inventoryDisplay.seeds.textContent = `BLACK HOLE SEEDS: ${inventory.seeds}`;
        }

        function openUpgradeMenu() {
            upgradeMenu.style.display = 'block';
        }

        function closeUpgradeMenu() {
            upgradeMenu.style.display = 'none';
        }

        function purchaseUpgrade(type) {
            switch(type) {
                case 'tractor':
                    if (inventory.fragments >= 5 && !upgrades.tractor) {
                        inventory.fragments -= 5;
                        upgrades.tractor = true;
                        updateInventoryDisplay();
                        alert("QUANTUM TRACTOR ARRAY ACTIVATED! Press E to fire 5 beams!");
                    } else if (upgrades.tractor) {
                        alert("You already have this upgrade!");
                    } else {
                        alert("Not enough Quantum Fragments!");
                    }
                    break;
                case 'color':
                    if (inventory.cores >= 3) {
                        inventory.cores -= 3;
                        currentColorIndex = (currentColorIndex + 1) % shipColors.length;
                        updateInventoryDisplay();
                        alert("CHROMATIC SHIFT ACTIVATED! Your ship has changed color!");
                    } else {
                        alert("Not enough Nebula Cores!");
                    }
                    break;
                case 'gravity':
                    if (inventory.seeds >= 2 && !upgrades.gravity) {
                        inventory.seeds -= 2;
                        upgrades.gravity = true;
                        updateInventoryDisplay();
                        alert("ANTI-GRAVITY BOOSTERS ACTIVATED! Gravity reduced by 50%!");
                    } else if (upgrades.gravity) {
                        alert("You already have this upgrade!");
                    } else {
                        alert("Not enough Black Hole Seeds!");
                    }
                    break;
                case 'size':
                    if (inventory.fragments >= 10 && inventory.cores >= 10 && inventory.seeds >= 10 && !upgrades.size) {
                        inventory.fragments -= 10;
                        inventory.cores -= 10;
                        inventory.seeds -= 10;
                        upgrades.size = true;
                        spider.baseRadius = 40;
                        updateInventoryDisplay();
                        alert("MASSIVE FORM ACTIVATED! You are now a GIANT COSMIC SPIDER!");
                    } else if (upgrades.size) {
                        alert("You already have this upgrade!");
                    } else {
                        alert("Not enough resources! Need 10 of each type.");
                    }
                    break;
            }
            closeUpgradeMenu();
        }

        function activatePower(power) {
            switch(power) {
                case 'time':
                    if (cosmicEnergy >= 10 && timeSlow === 1) {
                        cosmicEnergy -= 10;
                        timeSlow = 0.3;
                        powerDisplays.time.classList.add('active');
                        setTimeout(() => {
                            timeSlow = 1;
                            powerDisplays.time.classList.remove('active');
                        }, 3000 * (1/0.3));
                    }
                    break;
                case 'phase':
                    if (cosmicEnergy >= 15 && !isPhasing) {
                        cosmicEnergy -= 15;
                        isPhasing = true;
                        powerDisplays.phase.classList.add('active');
                        setTimeout(() => {
                            isPhasing = false;
                            powerDisplays.phase.classList.remove('active');
                        }, 2000);
                    }
                    break;
                case 'clone':
                    if (cosmicEnergy >= 20) {
                        cosmicEnergy -= 20;
                        createClone(spider.x, spider.y);
                        powerDisplays.clone.classList.add('active');
                        setTimeout(() => {
                            powerDisplays.clone.classList.remove('active');
                        }, 500);
                    }
                    break;
            }
        }

        // ======== VISUAL EFFECTS ========
        const stars = Array(1000).fill().map(() => ({
            x: Math.random() * worldWidth,
            y: Math.random() * worldHeight,
            size: Math.random() * 3,
            speed: 0.1 + Math.random() * 0.5,
            layer: Math.floor(Math.random() * 3) + 1
        }));

        function drawBackground() {
            const parallaxFactor = 0.05;
            const maxParallax = 2;
            const parallaxX = Math.max(-maxParallax, Math.min(maxParallax, spider.vx * parallaxFactor));
            const parallaxY = Math.max(-maxParallax, Math.min(maxParallax, spider.vy * parallaxFactor));

            ctx.fillStyle = 'white';
            stars.forEach(star => {
                // Calculate screen position with parallax
                const screenX = (star.x - cameraX * (star.layer * 0.3)) % width;
                const screenY = (star.y - cameraY * (star.layer * 0.3)) % height;
                
                // Wrap around edges
                const drawX = screenX < 0 ? screenX + width : screenX > width ? screenX - width : screenX;
                const drawY = screenY < 0 ? screenY + height : screenY > height ? screenY - height : screenY;

                ctx.globalAlpha = 0.3 + (star.layer / 3) * 0.7;
                ctx.beginPath();
                ctx.arc(drawX, drawY, star.size * (star.layer / 3), 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        // ======== GAME LOOP ========
        let lastTime = 0;
        function gameLoop(currentTime) {
            const deltaTime = (currentTime - lastTime) / 1000 || 0.016;
            lastTime = currentTime;
            gameTime += deltaTime * timeSlow;

            ctx.fillStyle = 'rgba(0, 0, 10, 0.2)';
            ctx.fillRect(0, 0, width, height);

            drawBackground();

            // Tractor beam timing logic
            if (isTractorBeamActive) {
                tractorBeamActiveTime += deltaTime;
                if (tractorBeamActiveTime >= 5) {
                    isTractorBeamActive = false;
                    isTractorBeamRetracting = true;
                } else {
                    tractorBeamPower = Math.min(tractorBeamPower + 0.05 * timeSlow, 1);
                }
            } else if (isTractorBeamRetracting) {
                tractorBeamPower = Math.max(tractorBeamPower - 0.02 * timeSlow, 0);
                if (tractorBeamPower <= 0.01) {
                    isTractorBeamRetracting = false;
                    tractorBeamActiveTime = 0;
                }
            }

            if (isTractorBeamActive && energy > 0) {
                energy = Math.max(energy - 0.004 * timeSlow, 0);
            } else if (!isThrusting && !isMouseForward && !isMouseBackward) {
                energy = Math.min(energy + 0.05 * timeSlow, 100);
            }

            energyBar.style.width = `${energy}%`;
            energyValue.textContent = `${Math.floor(energy)}%`;

            // Update score based on distance from center (for infinite mode)
            score = Math.max(score, Math.floor(Math.sqrt(
                Math.pow(spider.x - worldWidth/2, 2) + 
                Math.pow(spider.y - worldHeight/2, 2)
            ) / 10));
            scoreDisplay.textContent = `>> SCORE: ${score}`;

            // Spawn new objects and steps as needed
            spawnObjects();
            spawnSteps();

            // Update all game objects
            blackHoles.forEach(hole => hole.update());
            objects.forEach(obj => obj.update());
            clones = clones.filter(clone => clone.update());
            steps.forEach(step => step.draw());

            spider.update();
            checkCollisions();

            // Draw all game objects
            blackHoles.forEach(hole => hole.draw());
            objects.forEach(obj => obj.draw());
            clones.forEach(clone => clone.draw());
            spider.draw();

            // UI elements
            ctx.fillStyle = '#0ff';
            ctx.font = '16px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText(`QUANTUM ENERGY: ${cosmicEnergy}`, 20, height - 20);
            ctx.fillText(`POSITION: ${Math.floor(spider.x)}, ${Math.floor(spider.y)}`, 20, height - 50);

            requestAnimationFrame(gameLoop);
        }

        // ======== CONTROLS ========
        window.addEventListener('keydown', (e) => {
            switch (e.key.toLowerCase()) {
                case 'a': isRotatingLeft = true; break;
                case 'd': isRotatingRight = true; break;
                case 'w': isThrusting = true; break;
                case 's': isReversing = true; break;
                case 'e': 
                    if (!isTractorBeamRetracting) {
                        isTractorBeamActive = true;
                    }
                    break;
                case '1': activatePower('time'); break;
                case '2': activatePower('phase'); break;
                case '3': activatePower('clone'); break;
                case 'm':
                    music.paused ? music.play() : music.pause();
                    music.volume = 0.3;
                    break;
                case 'i': openUpgradeMenu(); break;
            }
        });

        window.addEventListener('keyup', (e) => {
            switch (e.key.toLowerCase()) {
                case 'a': isRotatingLeft = false; break;
                case 'd': isRotatingRight = false; break;
                case 'w': isThrusting = false; break;
                case 's': isReversing = false; break;
                case 'e': 
                    isTractorBeamActive = false;
                    break;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            const dx = mouseX - (spider.x - cameraX);
            const dy = mouseY - (spider.y - cameraY);
            tractorBeamAngle = Math.atan2(dy, dx);
        });

        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                isMouseForward = true;
            } else if (e.button === 2) {
                isMouseBackward = true;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                isMouseForward = false;
            } else if (e.button === 2) {
                isMouseBackward = false;
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // ======== INITIALIZATION ========
        function initGame() {
            // Generate initial world
            generateInitialWorld();
            
            // Load music
            loadMusic();
            
            // Hide loading screen
            loadingScreen.style.display = 'none';
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }

        function loadMusic() {
            try {
                music.src = "savagesally.wav";
                music.load();
                console.log("Loaded local music file");
            } catch (e) {
                console.error("Couldn't load local music file:", e);
                music.src = "https://assets.mixkit.co/music/preview/mixkit-ethereal-futuristic-classic-168.mp3";
                music.load();
            }
        }

        // Start game when user interacts
        let gameStarted = false;
        function startGame() {
            if (!gameStarted) {
                initGame();
                gameStarted = true;
                document.removeEventListener('click', startGame);
                document.removeEventListener('keydown', startGame);
            }
        }
        document.addEventListener('click', startGame);
        document.addEventListener('keydown', startGame);

        // Handle window resize
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        });
    </script>
</body>
</html>
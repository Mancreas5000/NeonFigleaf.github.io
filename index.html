<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Art Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars due to canvas */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
        }
        #app-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        #scene-container {
            width: 100%;
            height: calc(100vh - 80px); /* Adjust height to accommodate controls */
            position: relative;
            overflow: hidden;
            border-radius: 0.75rem; /* rounded-xl */
            background-color: #2d3748; /* Darker background for scene */
        }
        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }
        .controls {
            position: absolute;
            top: 1rem;
            left: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 10;
        }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2d3748;
            border: 1px solid #4a5568;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            text-align: center;
            display: none; /* Hidden by default */
        }
        .message-box button {
            margin-top: 1rem;
            padding: 0.5rem 1rem;
            background-color: #4299e1;
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .message-box button:hover {
            background-color: #3182ce;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">
    <div id="app-container" class="w-full max-w-7xl mx-auto p-4 flex flex-col items-center">
        <h1 class="text-4xl font-bold mb-6 text-blue-400">3D Art Studio</h1>
        <div id="scene-container" class="relative w-full h-[600px] bg-gray-800 rounded-xl shadow-lg overflow-hidden">
            <div class="controls p-4 bg-gray-700 bg-opacity-70 rounded-lg shadow-md">
                <button id="addCube" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white font-semibold rounded-md shadow-md transition duration-200 ease-in-out transform hover:scale-105">Add Cube</button>
                <button id="addSphere" class="px-4 py-2 bg-green-500 hover:bg-green-600 text-white font-semibold rounded-md shadow-md transition duration-200 ease-in-out transform hover:scale-105">Add Sphere</button>
                <button id="addCone" class="px-4 py-2 bg-purple-500 hover:bg-purple-600 text-white font-semibold rounded-md shadow-md transition duration-200 ease-in-out transform hover:scale-105">Add Cone</button>
                <button id="deleteSelected" class="px-4 py-2 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-md shadow-md transition duration-200 ease-in-out transform hover:scale-105">Delete Selected</button>
            </div>
        </div>
    </div>

    <div id="messageBox" class="message-box">
        <p id="messageText" class="text-lg"></p>
        <button id="closeMessageBox">OK</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        // Import OrbitControls as a module
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js';

        // Global variables for Three.js scene
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let draggableObjects = []; // Array to hold objects that can be dragged
        let selectedObject = null;
        let offset = new THREE.Vector3(); // Offset for dragging

        // Get DOM elements
        const sceneContainer = document.getElementById('scene-container');
        const addCubeBtn = document.getElementById('addCube');
        const addSphereBtn = document.getElementById('addSphere');
        const addConeBtn = document.getElementById('addCone');
        const deleteSelectedBtn = document.getElementById('deleteSelected');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const closeMessageBoxBtn = document.getElementById('closeMessageBox');

        // Function to show custom message box
        function showMessageBox(message) {
            messageText.textContent = message;
            messageBox.style.display = 'block';
        }

        // Event listener for closing message box
        closeMessageBoxBtn.addEventListener('click', () => {
            messageBox.style.display = 'none';
        });

        // Initialize the scene
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x36454F); // Dark slate gray background

            // Camera
            camera = new THREE.PerspectiveCamera(75, sceneContainer.clientWidth / sceneContainer.clientHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            sceneContainer.appendChild(renderer.domElement);

            // OrbitControls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth camera movement
            controls.dampingFactor = 0.25;
            controls.screenSpacePanning = false;
            controls.maxPolarAngle = Math.PI / 2; // Prevent camera from going below the ground

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            // Grid Helper
            const gridHelper = new THREE.GridHelper(10, 10);
            scene.add(gridHelper);

            // Raycaster for object picking
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Event Listeners for mouse interactions
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);

            // Event listeners for touch interactions (for mobile responsiveness)
            renderer.domElement.addEventListener('touchstart', onTouchStart, false);
            renderer.domElement.addEventListener('touchmove', onTouchMove, false);
            renderer.domElement.addEventListener('touchend', onTouchEnd, false);

            // Resize handler
            window.addEventListener('resize', onWindowResize, false);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Only required if controls.enableDamping is set to true
            renderer.render(scene, camera);
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = sceneContainer.clientWidth / sceneContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
        }

        // Function to add a shape
        function addShape(type) {
            let geometry;
            let material = new THREE.MeshPhongMaterial({ color: Math.random() * 0xffffff }); // Random color

            switch (type) {
                case 'cube':
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry(0.75, 32, 32);
                    break;
                case 'cone':
                    geometry = new THREE.ConeGeometry(0.7, 1.5, 32); // A cone can represent a triangle in 3D
                    break;
                default:
                    return;
            }

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(Math.random() * 4 - 2, 0.5, Math.random() * 4 - 2); // Random position
            scene.add(mesh);
            draggableObjects.push(mesh); // Add to draggable objects array
        }

        // Mouse down event handler
        function onMouseDown(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

            // Update the raycaster with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Find intersected objects
            const intersects = raycaster.intersectObjects(draggableObjects, true);

            if (intersects.length > 0) {
                selectedObject = intersects[0].object;
                controls.enabled = false; // Disable orbit controls when dragging

                // Calculate offset for dragging
                const plane = new THREE.Plane();
                plane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(plane.normal), selectedObject.position);
                raycaster.ray.intersectPlane(plane, offset);
                offset.sub(selectedObject.position);

                // Highlight selected object
                selectedObject.material.emissive.setHex(0x00ff00); // Green emissive color
            }
        }

        // Mouse move event handler
        function onMouseMove(event) {
            if (selectedObject) {
                // Update mouse position
                mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

                // Update raycaster
                raycaster.setFromCamera(mouse, camera);

                // Project selected object onto a plane for dragging
                const plane = new THREE.Plane();
                plane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(plane.normal), selectedObject.position);
                const intersectionPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersectionPoint);

                if (intersectionPoint) {
                    selectedObject.position.copy(intersectionPoint.sub(offset));
                }
            }
        }

        // Mouse up event handler
        function onMouseUp() {
            if (selectedObject) {
                selectedObject.material.emissive.setHex(0x000000); // Remove highlight
                selectedObject = null;
                controls.enabled = true; // Re-enable orbit controls
            }
        }

        // Touch event handlers (mimic mouse events for responsiveness)
        function onTouchStart(event) {
            if (event.touches.length === 1) {
                // Only handle single touch for dragging
                event.clientX = event.touches[0].clientX;
                event.clientY = event.touches[0].clientY;
                onMouseDown(event);
            }
        }

        function onTouchMove(event) {
            if (event.touches.length === 1) {
                event.clientX = event.touches[0].clientX;
                event.clientY = event.touches[0].clientY;
                onMouseMove(event);
            }
        }

        function onTouchEnd() {
            onMouseUp();
        }

        // Button event listeners
        addCubeBtn.addEventListener('click', () => addShape('cube'));
        addSphereBtn.addEventListener('click', () => addShape('sphere'));
        addConeBtn.addEventListener('click', () => addShape('cone'));

        deleteSelectedBtn.addEventListener('click', () => {
            if (selectedObject) {
                scene.remove(selectedObject);
                draggableObjects = draggableObjects.filter(obj => obj !== selectedObject);
                selectedObject = null;
                showMessageBox('Shape deleted successfully!');
            } else {
                showMessageBox('No shape selected to delete.');
            }
        });

        // Initialize and start animation when the window loads
        window.onload = function () {
            init();
            animate();
        };
    </script>
</body>
</html>
